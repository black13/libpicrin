#include "picrin.h"
#include "picrin/extra.h"

static const char boot_rom[][80] = {
"((core#lambda () (core#begin (core#define .define-transformer.2228 (core#lambda ",
"(.name.2248 .transformer.2249) (add-macro! .name.2248 .transformer.2249))) (core",
"#begin (core#define .the.2229 (core#lambda (.var.2250) (make-identifier .var.225",
"0 default-environment))) (core#begin (core#define .the-core-define.2230 (.the.22",
"29 (core#quote core#define))) (core#begin (core#define .the-core-lambda.2231 (.t",
"he.2229 (core#quote core#lambda))) (core#begin (core#define .the-core-begin.2232",
" (.the.2229 (core#quote core#begin))) (core#begin (core#define .the-core-quote.2",
"233 (.the.2229 (core#quote core#quote))) (core#begin (core#define .the-core-set!",
".2234 (.the.2229 (core#quote core#set!))) (core#begin (core#define .the-core-if.",
"2235 (.the.2229 (core#quote core#if))) (core#begin (core#define .the-core-define",
"-macro.2236 (.the.2229 (core#quote core#define-macro))) (core#begin (core#define",
" .the-define.2237 (.the.2229 (core#quote define))) (core#begin (core#define .the",
"-lambda.2238 (.the.2229 (core#quote lambda))) (core#begin (core#define .the-begi",
"n.2239 (.the.2229 (core#quote begin))) (core#begin (core#define .the-quote.2240 ",
"(.the.2229 (core#quote quote))) (core#begin (core#define .the-set!.2241 (.the.22",
"29 (core#quote set!))) (core#begin (core#define .the-if.2242 (.the.2229 (core#qu",
"ote if))) (core#begin (core#define .the-define-macro.2243 (.the.2229 (core#quote",
" define-macro))) (core#begin (.define-transformer.2228 (core#quote quote) (core#",
"lambda (.form.2251 .env.2252) (core#if (= (length .form.2251) 2) (cons .the-core",
"-quote.2233 (cons (cadr .form.2251) (core#quote ()))) (error \"malformed quote\" .",
"form.2251)))) (core#begin (.define-transformer.2228 (core#quote if) (core#lambda",
" (.form.2253 .env.2254) ((core#lambda (.len.2255) (core#if (= .len.2255 3) (appe",
"nd .form.2253 (cons (core#quote #undefined) (core#quote ()))) (core#if (= .len.2",
"255 4) (cons .the-core-if.2235 (cdr .form.2253)) (error \"malformed if\" .form.225",
"3)))) (length .form.2253)))) (core#begin (.define-transformer.2228 (core#quote b",
"egin) (core#lambda (.form.2256 .env.2257) ((core#lambda (.len.2258) (core#if (= ",
".len.2258 1) #undefined (core#if (= .len.2258 2) (cadr .form.2256) (core#if (= .",
"len.2258 3) (cons .the-core-begin.2232 (cdr .form.2256)) (cons .the-core-begin.2",
"232 (cons (cadr .form.2256) (cons (cons .the-begin.2239 (cddr .form.2256)) (core",
"#quote ())))))))) (length .form.2256)))) (core#begin (.define-transformer.2228 (",
"core#quote set!) (core#lambda (.form.2259 .env.2260) (core#if (core#if (= (lengt",
"h .form.2259) 3) (identifier? (cadr .form.2259)) #f) (cons .the-core-set!.2234 (",
"cdr .form.2259)) (error \"malformed set!\" .form.2259)))) (core#begin (core#define",
" .check-formal.2244 (core#lambda (.formal.2261) ((core#lambda (.it.2262) (core#i",
"f .it.2262 .it.2262 ((core#lambda (.it.2263) (core#if .it.2263 .it.2263 ((core#l",
"ambda (.it.2264) (core#if .it.2264 .it.2264 #f)) (core#if (pair? .formal.2261) (",
"core#if (identifier? (car .formal.2261)) (.check-formal.2244 (cdr .formal.2261))",
" #f) #f)))) (identifier? .formal.2261)))) (null? .formal.2261)))) (core#begin (.",
"define-transformer.2228 (core#quote lambda) (core#lambda (.form.2265 .env.2266) ",
"(core#if (= (length .form.2265) 1) (error \"malformed lambda\" .form.2265) (core#i",
"f (.check-formal.2244 (cadr .form.2265)) (cons .the-core-lambda.2231 (cons (cadr",
" .form.2265) (cons (cons .the-begin.2239 (cddr .form.2265)) (core#quote ())))) (",
"error \"malformed lambda\" .form.2265))))) (core#begin (.define-transformer.2228 (",
"core#quote define) (core#lambda (.form.2267 .env.2268) ((core#lambda (.len.2269)",
" (core#if (= .len.2269 1) (error \"malformed define\" .form.2267) ((core#lambda (.",
"formal.2270) (core#if (identifier? .formal.2270) (core#if (= .len.2269 3) (cons ",
".the-core-define.2230 (cdr .form.2267)) (error \"malformed define\" .form.2267)) (",
"core#if (pair? .formal.2270) (cons .the-define.2237 (cons (car .formal.2270) (co",
"ns (cons .the-lambda.2238 (cons (cdr .formal.2270) (cddr .form.2267))) (core#quo",
"te ())))) (error \"define: binding to non-varaible object\" .form.2267)))) (cadr .",
"form.2267)))) (length .form.2267)))) (core#begin (.define-transformer.2228 (core",
"#quote define-macro) (core#lambda (.form.2271 .env.2272) (core#if (= (length .fo",
"rm.2271) 3) (core#if (identifier? (cadr .form.2271)) (cons .the-core-define-macr",
"o.2236 (cdr .form.2271)) (error \"define-macro: binding to non-variable object\" .",
"form.2271)) (error \"malformed define-macro\" .form.2271)))) (core#begin #undefine",
"d (core#begin (.define-transformer.2228 (core#quote else) (core#lambda ._.2273 (",
"error \"invalid use of auxiliary syntax\" (core#quote else)))) (core#begin (.defin",
"e-transformer.2228 (core#quote =>) (core#lambda ._.2274 (error \"invalid use of a",
"uxiliary syntax\" (core#quote =>)))) (core#begin (.define-transformer.2228 (core#",
"quote unquote) (core#lambda ._.2275 (error \"invalid use of auxiliary syntax\" (co",
"re#quote unquote)))) (core#begin (.define-transformer.2228 (core#quote unquote-s",
"plicing) (core#lambda ._.2276 (error \"invalid use of auxiliary syntax\" (core#quo",
"te unquote-splicing)))) (core#begin (.define-transformer.2228 (core#quote let) (",
"core#lambda (.form.2277 .env.2278) (core#if (identifier? (cadr .form.2277)) ((co",
"re#lambda (.name.2279 .formal.2280 .body.2281) (cons (cons .the-lambda.2238 (con",
"s (core#quote ()) (cons (cons .the-define.2237 (cons (cons .name.2279 (map car .",
"formal.2280)) .body.2281)) (cons (cons .name.2279 (map cadr .formal.2280)) (core",
"#quote ()))))) (core#quote ()))) (car (cdr .form.2277)) (car (cdr (cdr .form.227",
"7))) (cdr (cdr (cdr .form.2277)))) ((core#lambda (.formal.2282 .body.2283) (cons",
" (cons .the-lambda.2238 (cons (map car .formal.2282) .body.2283)) (map cadr .for",
"mal.2282))) (car (cdr .form.2277)) (cdr (cdr .form.2277)))))) (core#begin (.defi",
"ne-transformer.2228 (core#quote and) (core#lambda (.form.2284 .env.2285) (core#i",
"f (null? (cdr .form.2284)) #t (core#if (null? (cddr .form.2284)) (cadr .form.228",
"4) (cons .the-if.2242 (cons (cadr .form.2284) (cons (cons (.the.2229 (core#quote",
" and)) (cddr .form.2284)) (cons (core#quote #f) (core#quote ()))))))))) (core#be",
"gin (.define-transformer.2228 (core#quote or) (core#lambda (.form.2286 .env.2287",
") (core#if (null? (cdr .form.2286)) #f ((core#lambda (.tmp.2288) (cons (.the.222",
"9 (core#quote let)) (cons (cons (cons .tmp.2288 (cons (cadr .form.2286) (core#qu",
"ote ()))) (core#quote ())) (cons (cons .the-if.2242 (cons .tmp.2288 (cons .tmp.2",
"288 (cons (cons (.the.2229 (core#quote or)) (cddr .form.2286)) (core#quote ())))",
")) (core#quote ()))))) (make-identifier (core#quote it) .env.2287))))) (core#beg",
"in (.define-transformer.2228 (core#quote cond) (core#lambda (.form.2289 .env.229",
"0) ((core#lambda (.clauses.2291) (core#if (null? .clauses.2291) #undefined ((cor",
"e#lambda (.clause.2292) (core#if (core#if (identifier? (car .clause.2292)) (iden",
"tifier=? (.the.2229 (core#quote else)) (make-identifier (car .clause.2292) .env.",
"2290)) #f) (cons .the-begin.2239 (cdr .clause.2292)) (core#if (null? (cdr .claus",
"e.2292)) (cons (.the.2229 (core#quote or)) (cons (car .clause.2292) (cons (cons ",
"(.the.2229 (core#quote cond)) (cdr .clauses.2291)) (core#quote ())))) (core#if (",
"core#if (identifier? (cadr .clause.2292)) (identifier=? (.the.2229 (core#quote =",
">)) (make-identifier (cadr .clause.2292) .env.2290)) #f) ((core#lambda (.tmp.229",
"3) (cons (.the.2229 (core#quote let)) (cons (cons (cons .tmp.2293 (cons (car .cl",
"ause.2292) (core#quote ()))) (core#quote ())) (cons (cons .the-if.2242 (cons .tm",
"p.2293 (cons (cons (cadr (cdr .clause.2292)) (cons .tmp.2293 (core#quote ()))) (",
"cons (cons (.the.2229 (core#quote cond)) (cddr .form.2289)) (core#quote ()))))) ",
"(core#quote ()))))) (make-identifier (core#quote tmp) .env.2290)) (cons .the-if.",
"2242 (cons (car .clause.2292) (cons (cons .the-begin.2239 (cdr .clause.2292)) (c",
"ons (cons (.the.2229 (core#quote cond)) (cdr .clauses.2291)) (core#quote ())))))",
")))) (car .clauses.2291)))) (cdr .form.2289)))) (core#begin (.define-transformer",
".2228 (core#quote quasiquote) (core#lambda (.form.2294 .env.2295) (core#begin (c",
"ore#define .quasiquote?.2296 (core#lambda (.form.2300) (core#if (pair? .form.230",
"0) (core#if (identifier? (car .form.2300)) (identifier=? (.the.2229 (core#quote ",
"quasiquote)) (make-identifier (car .form.2300) .env.2295)) #f) #f))) (core#begin",
" (core#define .unquote?.2297 (core#lambda (.form.2301) (core#if (pair? .form.230",
"1) (core#if (identifier? (car .form.2301)) (identifier=? (.the.2229 (core#quote ",
"unquote)) (make-identifier (car .form.2301) .env.2295)) #f) #f))) (core#begin (c",
"ore#define .unquote-splicing?.2298 (core#lambda (.form.2302) (core#if (pair? .fo",
"rm.2302) (core#if (pair? (car .form.2302)) (core#if (identifier? (caar .form.230",
"2)) (identifier=? (.the.2229 (core#quote unquote-splicing)) (make-identifier (ca",
"ar .form.2302) .env.2295)) #f) #f) #f))) (core#begin (core#define .qq.2299 (core",
"#lambda (.depth.2303 .expr.2304) (core#if (.unquote?.2297 .expr.2304) (core#if (",
"= .depth.2303 1) (cadr .expr.2304) (list (.the.2229 (core#quote list)) (list (.t",
"he.2229 (core#quote quote)) (.the.2229 (core#quote unquote))) (.qq.2299 (- .dept",
"h.2303 1) (car (cdr .expr.2304))))) (core#if (.unquote-splicing?.2298 .expr.2304",
") (core#if (= .depth.2303 1) (list (.the.2229 (core#quote append)) (car (cdr (ca",
"r .expr.2304))) (.qq.2299 .depth.2303 (cdr .expr.2304))) (list (.the.2229 (core#",
"quote cons)) (list (.the.2229 (core#quote list)) (list (.the.2229 (core#quote qu",
"ote)) (.the.2229 (core#quote unquote-splicing))) (.qq.2299 (- .depth.2303 1) (ca",
"r (cdr (car .expr.2304))))) (.qq.2299 .depth.2303 (cdr .expr.2304)))) (core#if (",
".quasiquote?.2296 .expr.2304) (list (.the.2229 (core#quote list)) (list (.the.22",
"29 (core#quote quote)) (.the.2229 (core#quote quasiquote))) (.qq.2299 (+ .depth.",
"2303 1) (car (cdr .expr.2304)))) (core#if (pair? .expr.2304) (list (.the.2229 (c",
"ore#quote cons)) (.qq.2299 .depth.2303 (car .expr.2304)) (.qq.2299 .depth.2303 (",
"cdr .expr.2304))) (core#if (vector? .expr.2304) (list (.the.2229 (core#quote lis",
"t->vector)) (.qq.2299 .depth.2303 (vector->list .expr.2304))) (list (.the.2229 (",
"core#quote quote)) .expr.2304)))))))) ((core#lambda (.x.2305) (.qq.2299 1 .x.230",
"5)) (cadr .form.2294)))))))) (core#begin (.define-transformer.2228 (core#quote l",
"et*) (core#lambda (.form.2306 .env.2307) ((core#lambda (.bindings.2308 .body.230",
"9) (core#if (null? .bindings.2308) (cons (.the.2229 (core#quote let)) (cons (cor",
"e#quote ()) .body.2309)) (cons (.the.2229 (core#quote let)) (cons (cons (cons (c",
"ar (car .bindings.2308)) (cdr (car .bindings.2308))) (core#quote ())) (cons (con",
"s (.the.2229 (core#quote let*)) (cons (cdr .bindings.2308) .body.2309)) (core#qu",
"ote ())))))) (car (cdr .form.2306)) (cdr (cdr .form.2306))))) (core#begin (.defi",
"ne-transformer.2228 (core#quote letrec) (core#lambda (.form.2310 .env.2311) (con",
"s (.the.2229 (core#quote letrec*)) (cdr .form.2310)))) (core#begin (.define-tran",
"sformer.2228 (core#quote letrec*) (core#lambda (.form.2312 .env.2313) ((core#lam",
"bda (.bindings.2314 .body.2315) ((core#lambda (.variables.2316 .initials.2317) (",
"cons (.the.2229 (core#quote let)) (cons .variables.2316 (append .initials.2317 (",
"append .body.2315 (core#quote ())))))) (map (core#lambda (.v.2318) (cons .v.2318",
" (cons (core#quote #undefined) (core#quote ())))) (map car .bindings.2314)) (map",
" (core#lambda (.v.2319) (cons (.the.2229 (core#quote set!)) (append .v.2319 (cor",
"e#quote ())))) .bindings.2314))) (car (cdr .form.2312)) (cdr (cdr .form.2312))))",
") (core#begin (.define-transformer.2228 (core#quote let-values) (core#lambda (.f",
"orm.2320 .env.2321) (cons (.the.2229 (core#quote let*-values)) (append (cdr .for",
"m.2320) (core#quote ()))))) (core#begin (.define-transformer.2228 (core#quote le",
"t*-values) (core#lambda (.form.2322 .env.2323) ((core#lambda (.formals.2324 .bod",
"y.2325) (core#if (null? .formals.2324) (cons (.the.2229 (core#quote let)) (cons ",
"(core#quote ()) (append .body.2325 (core#quote ())))) ((core#lambda (.formal.232",
"6) (cons (.the.2229 (core#quote call-with-values)) (cons (cons .the-lambda.2238 ",
"(cons (core#quote ()) (cdr .formal.2326))) (cons (cons (.the.2229 (core#quote la",
"mbda)) (cons (car .formal.2326) (cons (cons (.the.2229 (core#quote let*-values))",
" (cons (cdr .formals.2324) .body.2325)) (core#quote ())))) (core#quote ()))))) (",
"car .formals.2324)))) (cadr .form.2322) (cddr .form.2322)))) (core#begin (.defin",
"e-transformer.2228 (core#quote define-values) (core#lambda (.form.2327 .env.2328",
") ((core#lambda (.formal.2329 .body.2330) ((core#lambda (.arguments.2331) (cons ",
".the-begin.2239 (append ((core#lambda () (core#begin (core#define .loop.2332 (co",
"re#lambda (.formal.2333) (core#if (pair? .formal.2333) (cons (cons .the-define.2",
"237 (cons (car .formal.2333) (cons (core#quote #undefined) (core#quote ())))) (.",
"loop.2332 (cdr .formal.2333))) (core#if (identifier? .formal.2333) (cons (cons .",
"the-define.2237 (cons .formal.2333 (cons (core#quote #undefined) (core#quote ())",
"))) (core#quote ())) (core#quote ()))))) (.loop.2332 .formal.2329)))) (cons (con",
"s (.the.2229 (core#quote call-with-values)) (cons (cons .the-lambda.2238 (cons (",
"core#quote ()) (append .body.2330 (core#quote ())))) (cons (cons .the-lambda.223",
"8 (cons .arguments.2331 (append ((core#lambda () (core#begin (core#define .loop.",
"2334 (core#lambda (.formal.2335 .args.2336) (core#if (pair? .formal.2335) (cons ",
"(cons .the-set!.2241 (cons (car .formal.2335) (cons (cons (.the.2229 (core#quote",
" car)) (cons .args.2336 (core#quote ()))) (core#quote ())))) (.loop.2334 (cdr .f",
"ormal.2335) (cons (.the.2229 (core#quote cdr)) (cons .args.2336 (core#quote ()))",
"))) (core#if (identifier? .formal.2335) (cons (cons .the-set!.2241 (cons .formal",
".2335 (cons .args.2336 (core#quote ())))) (core#quote ())) (core#quote ()))))) (",
".loop.2334 .formal.2329 .arguments.2331)))) (core#quote ())))) (core#quote ())))",
") (core#quote ()))))) (make-identifier (core#quote arguments) .env.2328))) (cadr",
" .form.2327) (cddr .form.2327)))) (core#begin (.define-transformer.2228 (core#qu",
"ote do) (core#lambda (.form.2337 .env.2338) ((core#lambda (.bindings.2339 .test.",
"2340 .cleanup.2341 .body.2342) ((core#lambda (.loop.2343) (cons (.the.2229 (core",
"#quote let)) (cons .loop.2343 (cons (map (core#lambda (.x.2344) (cons (car .x.23",
"44) (cons (cadr .x.2344) (core#quote ())))) .bindings.2339) (cons (cons .the-if.",
"2242 (cons .test.2340 (cons (cons .the-begin.2239 .cleanup.2341) (cons (cons .th",
"e-begin.2239 (append .body.2342 (cons (cons .loop.2343 (map (core#lambda (.x.234",
"5) (core#if (null? (cdr (cdr .x.2345))) (car .x.2345) (car (cdr (cdr .x.2345))))",
") .bindings.2339)) (core#quote ())))) (core#quote ()))))) (core#quote ())))))) (",
"make-identifier (core#quote loop) .env.2338))) (car (cdr .form.2337)) (car (car ",
"(cdr (cdr .form.2337)))) (cdr (car (cdr (cdr .form.2337)))) (cdr (cdr (cdr .form",
".2337)))))) (core#begin (.define-transformer.2228 (core#quote when) (core#lambda",
" (.form.2346 .env.2347) ((core#lambda (.test.2348 .body.2349) (cons .the-if.2242",
" (cons .test.2348 (cons (cons .the-begin.2239 (append .body.2349 (core#quote ())",
")) (cons (core#quote #undefined) (core#quote ())))))) (car (cdr .form.2346)) (cd",
"r (cdr .form.2346))))) (core#begin (.define-transformer.2228 (core#quote unless)",
" (core#lambda (.form.2350 .env.2351) ((core#lambda (.test.2352 .body.2353) (cons",
" .the-if.2242 (cons .test.2352 (cons (core#quote #undefined) (cons (cons .the-be",
"gin.2239 (append .body.2353 (core#quote ()))) (core#quote ())))))) (car (cdr .fo",
"rm.2350)) (cdr (cdr .form.2350))))) (core#begin (.define-transformer.2228 (core#",
"quote case) (core#lambda (.form.2354 .env.2355) ((core#lambda (.key.2356 .clause",
"s.2357) ((core#lambda (.the-key.2358) (cons (.the.2229 (core#quote let)) (cons (",
"cons (cons .the-key.2358 (cons .key.2356 (core#quote ()))) (core#quote ())) (con",
"s ((core#lambda () (core#begin (core#define .loop.2359 (core#lambda (.clauses.23",
"60) (core#if (null? .clauses.2360) #undefined ((core#lambda (.clause.2361) (cons",
" .the-if.2242 (cons (core#if (core#if (identifier? (car .clause.2361)) (identifi",
"er=? (.the.2229 (core#quote else)) (make-identifier (car .clause.2361) .env.2355",
")) #f) #t (cons (.the.2229 (core#quote or)) (append (map (core#lambda (.x.2362) ",
"(cons (.the.2229 (core#quote eqv?)) (cons .the-key.2358 (cons (cons .the-quote.2",
"240 (cons .x.2362 (core#quote ()))) (core#quote ()))))) (car .clause.2361)) (cor",
"e#quote ())))) (cons (core#if (core#if (identifier? (cadr .clause.2361)) (identi",
"fier=? (.the.2229 (core#quote =>)) (make-identifier (cadr .clause.2361) .env.235",
"5)) #f) (cons (car (cdr (cdr .clause.2361))) (cons .the-key.2358 (core#quote ())",
")) (cons .the-begin.2239 (append (cdr .clause.2361) (core#quote ())))) (cons (.l",
"oop.2359 (cdr .clauses.2360)) (core#quote ())))))) (car .clauses.2360))))) (.loo",
"p.2359 .clauses.2357)))) (core#quote ()))))) (make-identifier (core#quote key) .",
"env.2355))) (car (cdr .form.2354)) (cdr (cdr .form.2354))))) (.define-transforme",
"r.2228 (core#quote parameterize) (core#lambda (.form.2363 .env.2364) ((core#lamb",
"da (.formal.2365 .body.2366) (cons (.the.2229 (core#quote with-dynamic-environme",
"nt)) (cons (cons (.the.2229 (core#quote list)) (append (map (core#lambda (.x.236",
"7) (cons (.the.2229 (core#quote cons)) (cons (car .x.2367) (cons (cadr .x.2367) ",
"(core#quote ()))))) .formal.2365) (core#quote ()))) (cons (cons .the-lambda.2238",
" (cons (core#quote ()) (append .body.2366 (core#quote ())))) (core#quote ())))))",
" (car (cdr .form.2363)) (cdr (cdr .form.2363))))))))))))))))))))))))))))))))))))",
")))))))))))))))",
};

#if PIC_USE_LIBRARY
static const char boot_library_rom[][80] = {
"(core#begin (core#define mangle (core#lambda (.name.2368) (core#begin (core#if (",
"null? .name.2368) (error \"library name should be a list of at least one symbols\"",
" .name.2368) #undefined) (core#begin (core#define .->string.2369 (core#lambda (.",
"n.2371) (core#if (symbol? .n.2371) ((core#lambda (.str.2372) (core#begin (string",
"-for-each (core#lambda (.c.2373) (core#if ((core#lambda (.it.2374) (core#if .it.",
"2374 .it.2374 ((core#lambda (.it.2375) (core#if .it.2375 .it.2375 #f)) (char=? .",
"c.2373 #\\:)))) (char=? .c.2373 #\\.)) (error \"elements of library name may not co",
"ntain '.' or ':'\" .n.2371) #undefined)) .str.2372) .str.2372)) (symbol->string .",
"n.2371)) (core#if (core#if (number? .n.2371) (core#if (exact? .n.2371) (<= 0 .n.",
"2371) #f) #f) (number->string .n.2371) (error \"symbol or non-negative integer is",
" required\" .n.2371))))) (core#begin (core#define .join.2370 (core#lambda (.strs.",
"2376 .delim.2377) ((core#lambda () (core#begin (core#define .loop.2378 (core#lam",
"bda (.res.2379 .strs.2380) (core#if (null? .strs.2380) .res.2379 (.loop.2378 (st",
"ring-append .res.2379 .delim.2377 (car .strs.2380)) (cdr .strs.2380))))) (.loop.",
"2378 (car .strs.2376) (cdr .strs.2376))))))) (core#if (symbol? .name.2368) .name",
".2368 (string->symbol (.join.2370 (map .->string.2369 .name.2368) \".\")))))))) (c",
"ore#begin (core#define current-library (make-parameter (core#quote (picrin user)",
") mangle)) (core#begin (core#define *libraries* (make-dictionary)) (core#begin (",
"core#define find-library (core#lambda (.name.2381) (dictionary-has? *libraries* ",
"(mangle .name.2381)))) (core#begin (core#define make-library (core#lambda (.name",
".2382) ((core#lambda (.name.2383) ((core#lambda (.env.2384 .exports.2385) (core#",
"begin (set-identifier! (core#quote define-library) (core#quote define-library) .",
"env.2384) (core#begin (set-identifier! (core#quote import) (core#quote import) .",
"env.2384) (core#begin (set-identifier! (core#quote export) (core#quote export) .",
"env.2384) (core#begin (set-identifier! (core#quote cond-expand) (core#quote cond",
"-expand) .env.2384) (dictionary-set! *libraries* .name.2383 (cons .env.2384 .exp",
"orts.2385))))))) (make-environment (string->symbol (string-append (symbol->strin",
"g .name.2383) \":\"))) (make-dictionary))) (mangle .name.2382)))) (core#begin (cor",
"e#define library-environment (core#lambda (.name.2386) (car (dictionary-ref *lib",
"raries* (mangle .name.2386))))) (core#begin (core#define library-exports (core#l",
"ambda (.name.2387) (cdr (dictionary-ref *libraries* (mangle .name.2387))))) (cor",
"e#begin (core#define library-import (core#lambda (.name.2388 .sym.2389 .alias.23",
"90) ((core#lambda (.uid.2391) ((core#lambda (.env.2392) (set-identifier! .alias.",
"2390 .uid.2391 .env.2392)) (library-environment (current-library)))) (dictionary",
"-ref (library-exports .name.2388) .sym.2389)))) (core#begin (core#define library",
"-export (core#lambda (.sym.2393 .alias.2394) ((core#lambda (.env.2395 .exports.2",
"396) (dictionary-set! .exports.2396 .alias.2394 (find-identifier .sym.2393 .env.",
"2395))) (library-environment (current-library)) (library-exports (current-librar",
"y))))) (core#begin ((core#lambda (.define-transformer.2397) (core#begin (.define",
"-transformer.2397 (core#quote define-library) (core#lambda (.form.2398 ._.2399) ",
"((core#lambda (.name.2400 .body.2401) (core#begin ((core#lambda (.it.2402) (core",
"#if .it.2402 .it.2402 ((core#lambda (.it.2403) (core#if .it.2403 .it.2403 #f)) (",
"make-library .name.2400)))) (find-library .name.2400)) (with-dynamic-environment",
" (list (cons current-library .name.2400)) (core#lambda () (for-each (core#lambda",
" (.expr.2404) (eval .expr.2404 .name.2400)) .body.2401))))) (cadr .form.2398) (c",
"ddr .form.2398)))) (core#begin (.define-transformer.2397 (core#quote cond-expand",
") (core#lambda (.form.2405 ._.2406) ((core#lambda (.test.2407) (core#begin (core",
"#set! .test.2407 (core#lambda (.form.2408) ((core#lambda (.it.2409) (core#if .it",
".2409 .it.2409 ((core#lambda (.it.2410) (core#if .it.2410 .it.2410 ((core#lambda",
" (.it.2411) (core#if .it.2411 .it.2411 #f)) (core#if (pair? .form.2408) ((core#l",
"ambda (.key.2412) (core#if ((core#lambda (.it.2413) (core#if .it.2413 .it.2413 #",
"f)) (eqv? .key.2412 (core#quote library))) (find-library (cadr .form.2408)) (cor",
"e#if ((core#lambda (.it.2414) (core#if .it.2414 .it.2414 #f)) (eqv? .key.2412 (c",
"ore#quote not))) (not (.test.2407 (cadr .form.2408))) (core#if ((core#lambda (.i",
"t.2415) (core#if .it.2415 .it.2415 #f)) (eqv? .key.2412 (core#quote and))) ((cor",
"e#lambda () (core#begin (core#define .loop.2416 (core#lambda (.form.2417) ((core",
"#lambda (.it.2418) (core#if .it.2418 .it.2418 ((core#lambda (.it.2419) (core#if ",
".it.2419 .it.2419 #f)) (core#if (.test.2407 (car .form.2417)) (.loop.2416 (cdr .",
"form.2417)) #f)))) (null? .form.2417)))) (.loop.2416 (cdr .form.2408))))) (core#",
"if ((core#lambda (.it.2420) (core#if .it.2420 .it.2420 #f)) (eqv? .key.2412 (cor",
"e#quote or))) ((core#lambda () (core#begin (core#define .loop.2421 (core#lambda ",
"(.form.2422) (core#if (pair? .form.2422) ((core#lambda (.it.2423) (core#if .it.2",
"423 .it.2423 ((core#lambda (.it.2424) (core#if .it.2424 .it.2424 #f)) (.loop.242",
"1 (cdr .form.2422))))) (.test.2407 (car .form.2422))) #f))) (.loop.2421 (cdr .fo",
"rm.2408))))) (core#if #t #f #undefined)))))) (car .form.2408)) #f)))) (core#if (",
"symbol? .form.2408) (memq .form.2408 (features)) #f)))) (eq? .form.2408 (core#qu",
"ote else))))) ((core#lambda () (core#begin (core#define .loop.2425 (core#lambda ",
"(.clauses.2426) (core#if (null? .clauses.2426) #undefined (core#if (.test.2407 (",
"caar .clauses.2426)) (cons (make-identifier (core#quote begin) default-environme",
"nt) (append (cdar .clauses.2426) (core#quote ()))) (.loop.2425 (cdr .clauses.242",
"6)))))) (.loop.2425 (cdr .form.2405))))))) #undefined))) (core#begin (.define-tr",
"ansformer.2397 (core#quote import) (core#lambda (.form.2427 ._.2428) ((core#lamb",
"da (.caddr.2429 .prefix.2430 .getlib.2431) ((core#lambda (.extract.2432 .collect",
".2433) (core#begin (core#set! .extract.2432 (core#lambda (.spec.2434) ((core#lam",
"bda (.key.2435) (core#if ((core#lambda (.it.2436) (core#if .it.2436 .it.2436 ((c",
"ore#lambda (.it.2437) (core#if .it.2437 .it.2437 ((core#lambda (.it.2438) (core#",
"if .it.2438 .it.2438 ((core#lambda (.it.2439) (core#if .it.2439 .it.2439 #f)) (e",
"qv? .key.2435 (core#quote except))))) (eqv? .key.2435 (core#quote prefix))))) (e",
"qv? .key.2435 (core#quote rename))))) (eqv? .key.2435 (core#quote only))) (.extr",
"act.2432 (cadr .spec.2434)) (core#if #t (.getlib.2431 .spec.2434) #undefined))) ",
"(car .spec.2434)))) (core#begin (core#set! .collect.2433 (core#lambda (.spec.244",
"0) ((core#lambda (.key.2441) (core#if ((core#lambda (.it.2442) (core#if .it.2442",
" .it.2442 #f)) (eqv? .key.2441 (core#quote only))) ((core#lambda (.alist.2443) (",
"map (core#lambda (.var.2444) (assq .var.2444 .alist.2443)) (cddr .spec.2440))) (",
".collect.2433 (cadr .spec.2440))) (core#if ((core#lambda (.it.2445) (core#if .it",
".2445 .it.2445 #f)) (eqv? .key.2441 (core#quote rename))) ((core#lambda (.alist.",
"2446 .renames.2447) (map (core#lambda (.s.2448) ((core#lambda (.it.2449) (core#i",
"f .it.2449 .it.2449 ((core#lambda (.it.2450) (core#if .it.2450 .it.2450 #f)) .s.",
"2448))) (assq (car .s.2448) .renames.2447))) .alist.2446)) (.collect.2433 (cadr ",
".spec.2440)) (map (core#lambda (.x.2451) (cons (car .x.2451) (cadr .x.2451))) (c",
"ddr .spec.2440))) (core#if ((core#lambda (.it.2452) (core#if .it.2452 .it.2452 #",
"f)) (eqv? .key.2441 (core#quote prefix))) ((core#lambda (.alist.2453) (map (core",
"#lambda (.s.2454) (cons (.prefix.2430 (.caddr.2429 .spec.2440) (car .s.2454)) (c",
"dr .s.2454))) .alist.2453)) (.collect.2433 (cadr .spec.2440))) (core#if ((core#l",
"ambda (.it.2455) (core#if .it.2455 .it.2455 #f)) (eqv? .key.2441 (core#quote exc",
"ept))) ((core#lambda (.alist.2456) ((core#lambda () (core#begin (core#define .lo",
"op.2457 (core#lambda (.alist.2458) (core#if (null? .alist.2458) (core#quote ()) ",
"(core#if (memq (caar .alist.2458) (cddr .spec.2440)) (.loop.2457 (cdr .alist.245",
"8)) (cons (car .alist.2458) (.loop.2457 (cdr .alist.2458))))))) (.loop.2457 .ali",
"st.2456))))) (.collect.2433 (cadr .spec.2440))) (core#if #t (dictionary-map (cor",
"e#lambda (.x.2459) (cons .x.2459 .x.2459)) (library-exports (.getlib.2431 .spec.",
"2440))) #undefined)))))) (car .spec.2440)))) ((core#lambda (.import.2460) (core#",
"begin (core#set! .import.2460 (core#lambda (.spec.2461) ((core#lambda (.lib.2462",
" .alist.2463) (for-each (core#lambda (.slot.2464) (library-import .lib.2462 (cdr",
" .slot.2464) (car .slot.2464))) .alist.2463)) (.extract.2432 .spec.2461) (.colle",
"ct.2433 .spec.2461)))) (for-each .import.2460 (cdr .form.2427)))) #undefined))))",
" #undefined #undefined)) (core#lambda (.x.2465) (car (cdr (cdr .x.2465)))) (core",
"#lambda (.prefix.2466 .symbol.2467) (string->symbol (string-append (symbol->stri",
"ng .prefix.2466) (symbol->string .symbol.2467)))) (core#lambda (.name.2468) (cor",
"e#if (find-library .name.2468) .name.2468 (error \"library not found\" .name.2468)",
"))))) (.define-transformer.2397 (core#quote export) (core#lambda (.form.2469 ._.",
"2470) ((core#lambda (.collect.2471 .export.2472) (core#begin (core#set! .collect",
".2471 (core#lambda (.spec.2473) (core#if (symbol? .spec.2473) (cons .spec.2473 .",
"spec.2473) (core#if (core#if (list? .spec.2473) (core#if (= (length .spec.2473) ",
"3) (eq? (car .spec.2473) (core#quote rename)) #f) #f) (cons (list-ref .spec.2473",
" 1) (list-ref .spec.2473 2)) (error \"malformed export\"))))) (core#begin (core#se",
"t! .export.2472 (core#lambda (.spec.2474) ((core#lambda (.slot.2475) (library-ex",
"port (car .slot.2475) (cdr .slot.2475))) (.collect.2471 .spec.2474)))) (for-each",
" .export.2472 (cdr .form.2469))))) #undefined #undefined))))))) (core#lambda (.n",
"ame.2476 .macro.2477) (add-macro! .name.2476 .macro.2477))) ((core#lambda () (co",
"re#begin (make-library (core#quote (picrin base))) (core#begin (set-car! (dictio",
"nary-ref *libraries* (mangle (core#quote (picrin base)))) default-environment) (",
"core#begin ((core#lambda (.export-keywords.2478) (core#begin (.export-keywords.2",
"478 (core#quote (define lambda quote set! if begin define-macro let let* letrec ",
"letrec* let-values let*-values define-values quasiquote unquote unquote-splicing",
" and or cond case else => do when unless parameterize))) (core#begin (.export-ke",
"ywords.2478 (core#quote (features eq? eqv? equal? not boolean? boolean=? pair? c",
"ons car cdr null? set-car! set-cdr! caar cadr cdar cddr list? make-list list len",
"gth append reverse list-tail list-ref list-set! list-copy map for-each memq memv",
" member assq assv assoc current-input-port current-output-port current-error-por",
"t port? input-port? output-port? port-open? close-port eof-object? eof-object re",
"ad-u8 peek-u8 read-bytevector! write-u8 write-bytevector flush-output-port open-",
"input-bytevector open-output-bytevector get-output-bytevector number? exact? ine",
"xact? inexact exact = < > <= >= + - * / number->string string->number procedure?",
" apply symbol? symbol=? symbol->string string->symbol make-identifier identifier",
"? identifier=? identifier-base identifier-environment vector? vector make-vector",
" vector-length vector-ref vector-set! vector-copy! vector-copy vector-append vec",
"tor-fill! vector-map vector-for-each list->vector vector->list string->vector ve",
"ctor->string bytevector? bytevector make-bytevector bytevector-length bytevector",
"-u8-ref bytevector-u8-set! bytevector-copy! bytevector-copy bytevector-append by",
"tevector->list list->bytevector call-with-current-continuation call/cc values ca",
"ll-with-values char? char->integer integer->char char=? char<? char>? char<=? ch",
"ar>=? current-exception-handlers with-exception-handler raise raise-continuable ",
"error error-object? error-object-message error-object-irritants error-object-typ",
"e string? string make-string string-length string-ref string-set! string-copy st",
"ring-copy! string-fill! string-append string-map string-for-each list->string st",
"ring->list string=? string<? string>? string<=? string>=? make-parameter with-dy",
"namic-environment read make-dictionary dictionary? dictionary dictionary-has? di",
"ctionary-ref dictionary-set! dictionary-delete! dictionary-size dictionary-map d",
"ictionary-for-each dictionary->alist alist->dictionary dictionary->plist plist->",
"dictionary make-record record? record-type record-datum default-environment make",
"-environment find-identifier set-identifier! eval compile add-macro! make-epheme",
"ron-table write write-simple write-shared display))) (.export-keywords.2478 (cor",
"e#quote (find-library make-library current-library)))))) (core#lambda (.keywords",
".2479) ((core#lambda (.env.2480 .exports.2481) (for-each (core#lambda (.keyword.",
"2482) (dictionary-set! .exports.2481 .keyword.2482 .keyword.2482)) .keywords.247",
"9)) (library-environment (core#quote (picrin base))) (library-exports (core#quot",
"e (picrin base)))))) (core#begin (core#set! eval ((core#lambda (.e.2483) (core#l",
"ambda (.expr.2484 . .lib.2485) ((core#lambda (.lib.2486) (.e.2483 .expr.2484 (li",
"brary-environment .lib.2486))) (core#if (null? .lib.2485) (current-library) (car",
" .lib.2485))))) eval)) (core#begin (make-library (core#quote (picrin user))) (cu",
"rrent-library (core#quote (picrin user))))))))))))))))))))",
};
#endif

void
pic_boot(pic_state *pic)
{
  pic_load_native(pic, &boot_rom[0][0]);
#if PIC_USE_LIBRARY
  pic_load_native(pic, &boot_library_rom[0][0]);
#endif
}
