#include "picrin.h"
#include "picrin/extra.h"

static const char boot_rom[][80] = {
"(core#begin (core#define transformer (core#lambda (.f.2252) (core#lambda (.form.",
"2253 .env.2254) ((core#lambda (.ephemeron1.2255 .ephemeron2.2256) ((core#lambda ",
"(.wrap.2257 .unwrap.2258 .walk.2259) (core#begin (core#set! .wrap.2257 (core#lam",
"bda (.var1.2260) ((core#lambda (.var2.2261) (core#if .var2.2261 (cdr .var2.2261)",
" ((core#lambda (.var2.2262) (core#begin (.ephemeron1.2255 .var1.2260 .var2.2262)",
" (core#begin (.ephemeron2.2256 .var2.2262 .var1.2260) .var2.2262))) (make-identi",
"fier .var1.2260 .env.2254)))) (.ephemeron1.2255 .var1.2260)))) (core#begin (core",
"#set! .unwrap.2258 (core#lambda (.var2.2263) ((core#lambda (.var1.2264) (core#if",
" .var1.2264 (cdr .var1.2264) .var2.2263)) (.ephemeron2.2256 .var2.2263)))) (core",
"#begin (core#set! .walk.2259 (core#lambda (.f.2265 .form.2266) (core#if (identif",
"ier? .form.2266) (.f.2265 .form.2266) (core#if (pair? .form.2266) (cons (.walk.2",
"259 .f.2265 (car .form.2266)) (.walk.2259 .f.2265 (cdr .form.2266))) (core#if (v",
"ector? .form.2266) (list->vector (.walk.2259 .f.2265 (vector->list .form.2266)))",
" .form.2266))))) ((core#lambda (.form.2267) (.walk.2259 .unwrap.2258 (apply .f.2",
"252 (.walk.2259 .wrap.2257 .form.2267)))) (cdr .form.2253)))))) #undefined #unde",
"fined #undefined)) (make-ephemeron-table) (make-ephemeron-table))))) ((core#lamb",
"da () (core#begin (core#define .define-transformer.2268 (core#lambda (.name.2288",
" .transformer.2289) (add-macro! .name.2288 .transformer.2289))) (core#begin (cor",
"e#define .the.2269 (core#lambda (.var.2290) (make-identifier .var.2290 default-e",
"nvironment))) (core#begin (core#define .the-core-define.2270 (.the.2269 (core#qu",
"ote core#define))) (core#begin (core#define .the-core-lambda.2271 (.the.2269 (co",
"re#quote core#lambda))) (core#begin (core#define .the-core-begin.2272 (.the.2269",
" (core#quote core#begin))) (core#begin (core#define .the-core-quote.2273 (.the.2",
"269 (core#quote core#quote))) (core#begin (core#define .the-core-set!.2274 (.the",
".2269 (core#quote core#set!))) (core#begin (core#define .the-core-if.2275 (.the.",
"2269 (core#quote core#if))) (core#begin (core#define .the-core-define-macro.2276",
" (.the.2269 (core#quote core#define-macro))) (core#begin (core#define .the-defin",
"e.2277 (.the.2269 (core#quote define))) (core#begin (core#define .the-lambda.227",
"8 (.the.2269 (core#quote lambda))) (core#begin (core#define .the-begin.2279 (.th",
"e.2269 (core#quote begin))) (core#begin (core#define .the-quote.2280 (.the.2269 ",
"(core#quote quote))) (core#begin (core#define .the-set!.2281 (.the.2269 (core#qu",
"ote set!))) (core#begin (core#define .the-if.2282 (.the.2269 (core#quote if))) (",
"core#begin (core#define .the-define-macro.2283 (.the.2269 (core#quote define-mac",
"ro))) (core#begin (.define-transformer.2268 (core#quote quote) (core#lambda (.fo",
"rm.2291 .env.2292) (core#if (= (length .form.2291) 2) (cons .the-core-quote.2273",
" (cons (cadr .form.2291) (core#quote ()))) (error \"malformed quote\" .form.2291))",
")) (core#begin (.define-transformer.2268 (core#quote if) (core#lambda (.form.229",
"3 .env.2294) ((core#lambda (.len.2295) (core#if (= .len.2295 3) (append .form.22",
"93 (cons (core#quote #undefined) (core#quote ()))) (core#if (= .len.2295 4) (con",
"s .the-core-if.2275 (cdr .form.2293)) (error \"malformed if\" .form.2293)))) (leng",
"th .form.2293)))) (core#begin (.define-transformer.2268 (core#quote begin) (core",
"#lambda (.form.2296 .env.2297) ((core#lambda (.len.2298) (core#if (= .len.2298 1",
") #undefined (core#if (= .len.2298 2) (cadr .form.2296) (core#if (= .len.2298 3)",
" (cons .the-core-begin.2272 (cdr .form.2296)) (cons .the-core-begin.2272 (cons (",
"cadr .form.2296) (cons (cons .the-begin.2279 (cddr .form.2296)) (core#quote ()))",
")))))) (length .form.2296)))) (core#begin (.define-transformer.2268 (core#quote ",
"set!) (core#lambda (.form.2299 .env.2300) (core#if (core#if (= (length .form.229",
"9) 3) (identifier? (cadr .form.2299)) #f) (cons .the-core-set!.2274 (cdr .form.2",
"299)) (error \"malformed set!\" .form.2299)))) (core#begin (core#define .check-for",
"mal.2284 (core#lambda (.formal.2301) ((core#lambda (.it.2302) (core#if .it.2302 ",
".it.2302 ((core#lambda (.it.2303) (core#if .it.2303 .it.2303 ((core#lambda (.it.",
"2304) (core#if .it.2304 .it.2304 #f)) (core#if (pair? .formal.2301) (core#if (id",
"entifier? (car .formal.2301)) (.check-formal.2284 (cdr .formal.2301)) #f) #f))))",
" (identifier? .formal.2301)))) (null? .formal.2301)))) (core#begin (.define-tran",
"sformer.2268 (core#quote lambda) (core#lambda (.form.2305 .env.2306) (core#if (=",
" (length .form.2305) 1) (error \"malformed lambda\" .form.2305) (core#if (.check-f",
"ormal.2284 (cadr .form.2305)) (cons .the-core-lambda.2271 (cons (cadr .form.2305",
") (cons (cons .the-begin.2279 (cddr .form.2305)) (core#quote ())))) (error \"malf",
"ormed lambda\" .form.2305))))) (core#begin (.define-transformer.2268 (core#quote ",
"define) (core#lambda (.form.2307 .env.2308) ((core#lambda (.len.2309) (core#if (",
"= .len.2309 1) (error \"malformed define\" .form.2307) ((core#lambda (.formal.2310",
") (core#if (identifier? .formal.2310) (core#if (= .len.2309 3) (cons .the-core-d",
"efine.2270 (cdr .form.2307)) (error \"malformed define\" .form.2307)) (core#if (pa",
"ir? .formal.2310) (cons .the-define.2277 (cons (car .formal.2310) (cons (cons .t",
"he-lambda.2278 (cons (cdr .formal.2310) (cddr .form.2307))) (core#quote ())))) (",
"error \"define: binding to non-varaible object\" .form.2307)))) (cadr .form.2307))",
")) (length .form.2307)))) (core#begin (.define-transformer.2268 (core#quote defi",
"ne-macro) (core#lambda (.form.2311 .env.2312) (core#if (= (length .form.2311) 3)",
" (core#if (identifier? (cadr .form.2311)) (cons .the-core-define-macro.2276 (cdr",
" .form.2311)) (error \"define-macro: binding to non-variable object\" .form.2311))",
" (error \"malformed define-macro\" .form.2311)))) (core#begin (.define-transformer",
".2268 (core#quote syntax-error) (core#lambda (.form.2313 ._.2314) (apply error (",
"cdr .form.2313)))) (core#begin #undefined (core#begin (.define-transformer.2268 ",
"(core#quote else) (core#lambda ._.2315 (error \"invalid use of auxiliary syntax\" ",
"(core#quote else)))) (core#begin (.define-transformer.2268 (core#quote =>) (core",
"#lambda ._.2316 (error \"invalid use of auxiliary syntax\" (core#quote =>)))) (cor",
"e#begin (.define-transformer.2268 (core#quote unquote) (core#lambda ._.2317 (err",
"or \"invalid use of auxiliary syntax\" (core#quote unquote)))) (core#begin (.defin",
"e-transformer.2268 (core#quote unquote-splicing) (core#lambda ._.2318 (error \"in",
"valid use of auxiliary syntax\" (core#quote unquote-splicing)))) (core#begin (.de",
"fine-transformer.2268 (core#quote syntax-unquote) (core#lambda ._.2319 (error \"i",
"nvalid use of auxiliary syntax\" (core#quote syntax-unquote)))) (core#begin (.def",
"ine-transformer.2268 (core#quote syntax-unquote-splicing) (core#lambda ._.2320 (",
"error \"invalid use of auxiliary syntax\" (core#quote syntax-unquote-splicing)))) ",
"(core#begin (.define-transformer.2268 (core#quote let) (core#lambda (.form.2321 ",
".env.2322) (core#if (identifier? (cadr .form.2321)) ((core#lambda (.name.2323 .f",
"ormal.2324 .body.2325) (cons (cons .the-lambda.2278 (cons (core#quote ()) (cons ",
"(cons .the-define.2277 (cons (cons .name.2323 (map car .formal.2324)) .body.2325",
")) (cons (cons .name.2323 (map cadr .formal.2324)) (core#quote ()))))) (core#quo",
"te ()))) (car (cdr .form.2321)) (car (cdr (cdr .form.2321))) (cdr (cdr (cdr .for",
"m.2321)))) ((core#lambda (.formal.2326 .body.2327) (cons (cons .the-lambda.2278 ",
"(cons (map car .formal.2326) .body.2327)) (map cadr .formal.2326))) (car (cdr .f",
"orm.2321)) (cdr (cdr .form.2321)))))) (core#begin (.define-transformer.2268 (cor",
"e#quote and) (core#lambda (.form.2328 .env.2329) (core#if (null? (cdr .form.2328",
")) #t (core#if (null? (cddr .form.2328)) (cadr .form.2328) (cons .the-if.2282 (c",
"ons (cadr .form.2328) (cons (cons (.the.2269 (core#quote and)) (cddr .form.2328)",
") (cons (core#quote #f) (core#quote ()))))))))) (core#begin (.define-transformer",
".2268 (core#quote or) (core#lambda (.form.2330 .env.2331) (core#if (null? (cdr .",
"form.2330)) #f ((core#lambda (.tmp.2332) (cons (.the.2269 (core#quote let)) (con",
"s (cons (cons .tmp.2332 (cons (cadr .form.2330) (core#quote ()))) (core#quote ()",
")) (cons (cons .the-if.2282 (cons .tmp.2332 (cons .tmp.2332 (cons (cons (.the.22",
"69 (core#quote or)) (cddr .form.2330)) (core#quote ()))))) (core#quote ()))))) (",
"make-identifier (core#quote it) .env.2331))))) (core#begin (.define-transformer.",
"2268 (core#quote cond) (core#lambda (.form.2333 .env.2334) ((core#lambda (.claus",
"es.2335) (core#if (null? .clauses.2335) #undefined ((core#lambda (.clause.2336) ",
"(core#if (core#if (identifier? (car .clause.2336)) (identifier=? (.the.2269 (cor",
"e#quote else)) (make-identifier (car .clause.2336) .env.2334)) #f) (cons .the-be",
"gin.2279 (cdr .clause.2336)) (core#if (null? (cdr .clause.2336)) (cons (.the.226",
"9 (core#quote or)) (cons (car .clause.2336) (cons (cons (.the.2269 (core#quote c",
"ond)) (cdr .clauses.2335)) (core#quote ())))) (core#if (core#if (identifier? (ca",
"dr .clause.2336)) (identifier=? (.the.2269 (core#quote =>)) (make-identifier (ca",
"dr .clause.2336) .env.2334)) #f) ((core#lambda (.tmp.2337) (cons (.the.2269 (cor",
"e#quote let)) (cons (cons (cons .tmp.2337 (cons (car .clause.2336) (core#quote (",
")))) (core#quote ())) (cons (cons .the-if.2282 (cons .tmp.2337 (cons (cons (cadr",
" (cdr .clause.2336)) (cons .tmp.2337 (core#quote ()))) (cons (cons (.the.2269 (c",
"ore#quote cond)) (cddr .form.2333)) (core#quote ()))))) (core#quote ()))))) (mak",
"e-identifier (core#quote tmp) .env.2334)) (cons .the-if.2282 (cons (car .clause.",
"2336) (cons (cons .the-begin.2279 (cdr .clause.2336)) (cons (cons (.the.2269 (co",
"re#quote cond)) (cdr .clauses.2335)) (core#quote ()))))))))) (car .clauses.2335)",
"))) (cdr .form.2333)))) (core#begin (.define-transformer.2268 (core#quote quasiq",
"uote) (core#lambda (.form.2338 .env.2339) (core#begin (core#define .quasiquote?.",
"2340 (core#lambda (.form.2344) (core#if (pair? .form.2344) (core#if (identifier?",
" (car .form.2344)) (identifier=? (.the.2269 (core#quote quasiquote)) (make-ident",
"ifier (car .form.2344) .env.2339)) #f) #f))) (core#begin (core#define .unquote?.",
"2341 (core#lambda (.form.2345) (core#if (pair? .form.2345) (core#if (identifier?",
" (car .form.2345)) (identifier=? (.the.2269 (core#quote unquote)) (make-identifi",
"er (car .form.2345) .env.2339)) #f) #f))) (core#begin (core#define .unquote-spli",
"cing?.2342 (core#lambda (.form.2346) (core#if (pair? .form.2346) (core#if (pair?",
" (car .form.2346)) (core#if (identifier? (caar .form.2346)) (identifier=? (.the.",
"2269 (core#quote unquote-splicing)) (make-identifier (caar .form.2346) .env.2339",
")) #f) #f) #f))) (core#begin (core#define .qq.2343 (core#lambda (.depth.2347 .ex",
"pr.2348) (core#if (.unquote?.2341 .expr.2348) (core#if (= .depth.2347 1) (cadr .",
"expr.2348) (list (.the.2269 (core#quote list)) (list (.the.2269 (core#quote quot",
"e)) (.the.2269 (core#quote unquote))) (.qq.2343 (- .depth.2347 1) (car (cdr .exp",
"r.2348))))) (core#if (.unquote-splicing?.2342 .expr.2348) (core#if (= .depth.234",
"7 1) (list (.the.2269 (core#quote append)) (car (cdr (car .expr.2348))) (.qq.234",
"3 .depth.2347 (cdr .expr.2348))) (list (.the.2269 (core#quote cons)) (list (.the",
".2269 (core#quote list)) (list (.the.2269 (core#quote quote)) (.the.2269 (core#q",
"uote unquote-splicing))) (.qq.2343 (- .depth.2347 1) (car (cdr (car .expr.2348))",
"))) (.qq.2343 .depth.2347 (cdr .expr.2348)))) (core#if (.quasiquote?.2340 .expr.",
"2348) (list (.the.2269 (core#quote list)) (list (.the.2269 (core#quote quote)) (",
".the.2269 (core#quote quasiquote))) (.qq.2343 (+ .depth.2347 1) (car (cdr .expr.",
"2348)))) (core#if (pair? .expr.2348) (list (.the.2269 (core#quote cons)) (.qq.23",
"43 .depth.2347 (car .expr.2348)) (.qq.2343 .depth.2347 (cdr .expr.2348))) (core#",
"if (vector? .expr.2348) (list (.the.2269 (core#quote list->vector)) (.qq.2343 .d",
"epth.2347 (vector->list .expr.2348))) (list (.the.2269 (core#quote quote)) .expr",
".2348)))))))) ((core#lambda (.x.2349) (.qq.2343 1 .x.2349)) (cadr .form.2338))))",
")))) (core#begin (.define-transformer.2268 (core#quote let*) (core#lambda (.form",
".2350 .env.2351) ((core#lambda (.bindings.2352 .body.2353) (core#if (null? .bind",
"ings.2352) (cons (.the.2269 (core#quote let)) (cons (core#quote ()) .body.2353))",
" (cons (.the.2269 (core#quote let)) (cons (cons (cons (car (car .bindings.2352))",
" (cdr (car .bindings.2352))) (core#quote ())) (cons (cons (.the.2269 (core#quote",
" let*)) (cons (cdr .bindings.2352) .body.2353)) (core#quote ())))))) (car (cdr .",
"form.2350)) (cdr (cdr .form.2350))))) (core#begin (.define-transformer.2268 (cor",
"e#quote letrec) (core#lambda (.form.2354 .env.2355) (cons (.the.2269 (core#quote",
" letrec*)) (cdr .form.2354)))) (core#begin (.define-transformer.2268 (core#quote",
" letrec*) (core#lambda (.form.2356 .env.2357) ((core#lambda (.bindings.2358 .bod",
"y.2359) ((core#lambda (.variables.2360 .initials.2361) (cons (.the.2269 (core#qu",
"ote let)) (cons .variables.2360 (append .initials.2361 (append .body.2359 (core#",
"quote ())))))) (map (core#lambda (.v.2362) (cons .v.2362 (cons (core#quote #unde",
"fined) (core#quote ())))) (map car .bindings.2358)) (map (core#lambda (.v.2363) ",
"(cons (.the.2269 (core#quote set!)) (append .v.2363 (core#quote ())))) .bindings",
".2358))) (car (cdr .form.2356)) (cdr (cdr .form.2356))))) (core#begin (.define-t",
"ransformer.2268 (core#quote let-values) (core#lambda (.form.2364 .env.2365) (con",
"s (.the.2269 (core#quote let*-values)) (append (cdr .form.2364) (core#quote ()))",
"))) (core#begin (.define-transformer.2268 (core#quote let*-values) (core#lambda ",
"(.form.2366 .env.2367) ((core#lambda (.formal.2368 .body.2369) (core#if (null? .",
"formal.2368) (cons (.the.2269 (core#quote let)) (cons (core#quote ()) (append .b",
"ody.2369 (core#quote ())))) (cons (.the.2269 (core#quote call-with-values)) (con",
"s (cons .the-lambda.2278 (cons (core#quote ()) (append (cdr (car .formal.2368)) ",
"(core#quote ())))) (cons (cons (.the.2269 (core#quote lambda)) (cons (append (ca",
"r (car .formal.2368)) (core#quote ())) (cons (cons (.the.2269 (core#quote let*-v",
"alues)) (cons (append (cdr .formal.2368) (core#quote ())) (append .body.2369 (co",
"re#quote ())))) (core#quote ())))) (core#quote ())))))) (car (cdr .form.2366)) (",
"cdr (cdr .form.2366))))) (core#begin (.define-transformer.2268 (core#quote defin",
"e-values) (core#lambda (.form.2370 .env.2371) ((core#lambda (.formal.2372 .body.",
"2373) ((core#lambda (.arguments.2374) (cons .the-begin.2279 (append ((core#lambd",
"a () (core#begin (core#define .loop.2375 (core#lambda (.formal.2376) (core#if (p",
"air? .formal.2376) (cons (cons .the-define.2277 (cons (car .formal.2376) (cons (",
"core#quote #undefined) (core#quote ())))) (append (.loop.2375 (cdr .formal.2376)",
") (core#quote ()))) (core#if (identifier? .formal.2376) (cons (cons .the-define.",
"2277 (cons .formal.2376 (cons (core#quote #undefined) (core#quote ())))) (core#q",
"uote ())) (core#quote ()))))) (.loop.2375 .formal.2372)))) (cons (cons (.the.226",
"9 (core#quote call-with-values)) (cons (cons .the-lambda.2278 (cons (core#quote ",
"()) (append .body.2373 (core#quote ())))) (cons (cons .the-lambda.2278 (cons .ar",
"guments.2374 (append ((core#lambda () (core#begin (core#define .loop.2377 (core#",
"lambda (.formal.2378 .args.2379) (core#if (pair? .formal.2378) (cons (cons .the-",
"set!.2281 (cons (car .formal.2378) (cons (cons (.the.2269 (core#quote car)) (con",
"s .args.2379 (core#quote ()))) (core#quote ())))) (append (.loop.2377 (cdr .form",
"al.2378) (cons (.the.2269 (core#quote cdr)) (cons .args.2379 (core#quote ())))) ",
"(core#quote ()))) (core#if (identifier? .formal.2378) (cons (cons .the-set!.2281",
" (cons .formal.2378 (cons .args.2379 (core#quote ())))) (core#quote ())) (core#q",
"uote ()))))) (.loop.2377 .formal.2372 .arguments.2374)))) (core#quote ())))) (co",
"re#quote ())))) (core#quote ()))))) (make-identifier (core#quote arguments) .env",
".2371))) (car (cdr .form.2370)) (cdr (cdr .form.2370))))) (core#begin (.define-t",
"ransformer.2268 (core#quote do) (core#lambda (.form.2380 .env.2381) ((core#lambd",
"a (.bindings.2382 .test.2383 .cleanup.2384 .body.2385) ((core#lambda (.loop.2386",
") (cons (.the.2269 (core#quote let)) (cons .loop.2386 (cons (map (core#lambda (.",
"x.2387) (cons (car .x.2387) (cons (cadr .x.2387) (core#quote ())))) .bindings.23",
"82) (cons (cons .the-if.2282 (cons .test.2383 (cons (cons .the-begin.2279 .clean",
"up.2384) (cons (cons .the-begin.2279 (append .body.2385 (cons (cons .loop.2386 (",
"map (core#lambda (.x.2388) (core#if (null? (cdr (cdr .x.2388))) (car .x.2388) (c",
"ar (cdr (cdr .x.2388))))) .bindings.2382)) (core#quote ())))) (core#quote ()))))",
") (core#quote ())))))) (make-identifier (core#quote loop) .env.2381))) (car (cdr",
" .form.2380)) (car (car (cdr (cdr .form.2380)))) (cdr (car (cdr (cdr .form.2380)",
"))) (cdr (cdr (cdr .form.2380)))))) (core#begin (.define-transformer.2268 (core#",
"quote when) (core#lambda (.form.2389 .env.2390) ((core#lambda (.test.2391 .body.",
"2392) (cons .the-if.2282 (cons .test.2391 (cons (cons .the-begin.2279 (append .b",
"ody.2392 (core#quote ()))) (cons (core#quote #undefined) (core#quote ())))))) (c",
"ar (cdr .form.2389)) (cdr (cdr .form.2389))))) (core#begin (.define-transformer.",
"2268 (core#quote unless) (core#lambda (.form.2393 .env.2394) ((core#lambda (.tes",
"t.2395 .body.2396) (cons .the-if.2282 (cons .test.2395 (cons (core#quote #undefi",
"ned) (cons (cons .the-begin.2279 (append .body.2396 (core#quote ()))) (core#quot",
"e ())))))) (car (cdr .form.2393)) (cdr (cdr .form.2393))))) (core#begin (.define",
"-transformer.2268 (core#quote case) (core#lambda (.form.2397 .env.2398) ((core#l",
"ambda (.key.2399 .clauses.2400) ((core#lambda (.the-key.2401) (cons (.the.2269 (",
"core#quote let)) (cons (cons (cons .the-key.2401 (cons .key.2399 (core#quote ())",
")) (core#quote ())) (cons ((core#lambda () (core#begin (core#define .loop.2402 (",
"core#lambda (.clauses.2403) (core#if (null? .clauses.2403) #undefined ((core#lam",
"bda (.clause.2404) (cons .the-if.2282 (cons (core#if (core#if (identifier? (car ",
".clause.2404)) (identifier=? (.the.2269 (core#quote else)) (make-identifier (car",
" .clause.2404) .env.2398)) #f) #t (cons (.the.2269 (core#quote or)) (append (map",
" (core#lambda (.x.2405) (cons (.the.2269 (core#quote eqv?)) (cons .the-key.2401 ",
"(cons (cons .the-quote.2280 (cons .x.2405 (core#quote ()))) (core#quote ()))))) ",
"(car .clause.2404)) (core#quote ())))) (cons (core#if (core#if (identifier? (cad",
"r .clause.2404)) (identifier=? (.the.2269 (core#quote =>)) (make-identifier (cad",
"r .clause.2404) .env.2398)) #f) (cons (car (cdr (cdr .clause.2404))) (cons .the-",
"key.2401 (core#quote ()))) (cons .the-begin.2279 (append (cdr .clause.2404) (cor",
"e#quote ())))) (cons (.loop.2402 (cdr .clauses.2403)) (core#quote ())))))) (car ",
".clauses.2403))))) (.loop.2402 .clauses.2400)))) (core#quote ()))))) (make-ident",
"ifier (core#quote key) .env.2398))) (car (cdr .form.2397)) (cdr (cdr .form.2397)",
")))) (core#begin (.define-transformer.2268 (core#quote parameterize) (core#lambd",
"a (.form.2406 .env.2407) ((core#lambda (.formal.2408 .body.2409) (cons (.the.226",
"9 (core#quote with-dynamic-environment)) (cons (cons (.the.2269 (core#quote list",
")) (append (map (core#lambda (.x.2410) (cons (.the.2269 (core#quote cons)) (cons",
" (car .x.2410) (cons (cadr .x.2410) (core#quote ()))))) .formal.2408) (core#quot",
"e ()))) (cons (cons .the-lambda.2278 (cons (core#quote ()) (append .body.2409 (c",
"ore#quote ())))) (core#quote ()))))) (car (cdr .form.2406)) (cdr (cdr .form.2406",
"))))) (core#begin (.define-transformer.2268 (core#quote syntax-quote) (core#lamb",
"da (.form.2411 .env.2412) ((core#lambda (.renames.2413) ((core#lambda (.rename.2",
"414 .walk.2415) (core#begin (core#set! .rename.2414 (core#lambda (.var.2416) ((c",
"ore#lambda (.x.2417) (core#if .x.2417 (cadr .x.2417) (core#begin (core#set! .ren",
"ames.2413 (cons (cons .var.2416 (cons (make-identifier .var.2416 .env.2412) (con",
"s (cons (.the.2269 (core#quote make-identifier)) (cons (cons (core#quote quote) ",
"(cons .var.2416 (core#quote ()))) (cons (cons (core#quote quote) (cons .env.2412",
" (core#quote ()))) (core#quote ())))) (core#quote ())))) .renames.2413)) (.renam",
"e.2414 .var.2416)))) (assq .var.2416 .renames.2413)))) (core#begin (core#set! .w",
"alk.2415 (core#lambda (.f.2418 .form.2419) (core#if (identifier? .form.2419) (.f",
".2418 .form.2419) (core#if (pair? .form.2419) (cons (.the.2269 (core#quote cons)",
") (cons (cons (core#quote walk) (cons (core#quote f) (cons (cons (core#quote car",
") (cons (core#quote form) (core#quote ()))) (core#quote ())))) (cons (cons (core",
"#quote walk) (cons (core#quote f) (cons (cons (core#quote cdr) (cons (core#quote",
" form) (core#quote ()))) (core#quote ())))) (core#quote ())))) (core#if (vector?",
" .form.2419) (cons (.the.2269 (core#quote list->vector)) (cons (cons (core#quote",
" walk) (cons (core#quote f) (cons (cons (core#quote vector->list) (cons (core#qu",
"ote form) (core#quote ()))) (core#quote ())))) (core#quote ()))) (cons (.the.226",
"9 (core#quote quote)) (cons .form.2419 (core#quote ())))))))) ((core#lambda (.fo",
"rm.2420) (cons (.the.2269 (core#quote let)) (cons (map cdr .renames.2413) (cons ",
".form.2420 (core#quote ()))))) (.walk.2415 .rename.2414 (cadr .form.2411)))))) #",
"undefined #undefined)) (core#quote ())))) (core#begin (.define-transformer.2268 ",
"(core#quote syntax-quasiquote) (core#lambda (.form.2421 .env.2422) ((core#lambda",
" (.renames.2423) ((core#lambda (.rename.2424) (core#begin (core#set! .rename.242",
"4 (core#lambda (.var.2429) ((core#lambda (.x.2430) (core#if .x.2430 (cadr .x.243",
"0) (core#begin (core#set! .renames.2423 (cons (cons .var.2429 (cons (make-identi",
"fier .var.2429 .env.2422) (cons (cons (.the.2269 (core#quote make-identifier)) (",
"cons (cons (core#quote quote) (cons .var.2429 (core#quote ()))) (cons (cons (cor",
"e#quote quote) (cons .env.2422 (core#quote ()))) (core#quote ())))) (core#quote ",
"())))) .renames.2423)) (.rename.2424 .var.2429)))) (assq .var.2429 .renames.2423",
")))) (core#begin (core#define .syntax-quasiquote?.2425 (core#lambda (.form.2431)",
" (core#if (pair? .form.2431) (core#if (identifier? (car .form.2431)) (identifier",
"=? (.the.2269 (core#quote syntax-quasiquote)) (make-identifier (car .form.2431) ",
".env.2422)) #f) #f))) (core#begin (core#define .syntax-unquote?.2426 (core#lambd",
"a (.form.2432) (core#if (pair? .form.2432) (core#if (identifier? (car .form.2432",
")) (identifier=? (.the.2269 (core#quote syntax-unquote)) (make-identifier (car .",
"form.2432) .env.2422)) #f) #f))) (core#begin (core#define .syntax-unquote-splici",
"ng?.2427 (core#lambda (.form.2433) (core#if (pair? .form.2433) (core#if (pair? (",
"car .form.2433)) (core#if (identifier? (caar .form.2433)) (identifier=? (.the.22",
"69 (core#quote syntax-unquote-splicing)) (make-identifier (caar .form.2433) .env",
".2422)) #f) #f) #f))) (core#begin (core#define .qq.2428 (core#lambda (.depth.243",
"4 .expr.2435) (core#if (.syntax-unquote?.2426 .expr.2435) (core#if (= .depth.243",
"4 1) (car (cdr .expr.2435)) (list (.the.2269 (core#quote list)) (list (.the.2269",
" (core#quote quote)) (.the.2269 (core#quote syntax-unquote))) (.qq.2428 (- .dept",
"h.2434 1) (car (cdr .expr.2435))))) (core#if (.syntax-unquote-splicing?.2427 .ex",
"pr.2435) (core#if (= .depth.2434 1) (list (.the.2269 (core#quote append)) (car (",
"cdr (car .expr.2435))) (.qq.2428 .depth.2434 (cdr .expr.2435))) (list (.the.2269",
" (core#quote cons)) (list (.the.2269 (core#quote list)) (list (.the.2269 (core#q",
"uote quote)) (.the.2269 (core#quote syntax-unquote-splicing))) (.qq.2428 (- .dep",
"th.2434 1) (car (cdr (car .expr.2435))))) (.qq.2428 .depth.2434 (cdr .expr.2435)",
"))) (core#if (.syntax-quasiquote?.2425 .expr.2435) (list (.the.2269 (core#quote ",
"list)) (list (.the.2269 (core#quote quote)) (.the.2269 (core#quote quasiquote)))",
" (.qq.2428 (+ .depth.2434 1) (car (cdr .expr.2435)))) (core#if (pair? .expr.2435",
") (list (.the.2269 (core#quote cons)) (.qq.2428 .depth.2434 (car .expr.2435)) (.",
"qq.2428 .depth.2434 (cdr .expr.2435))) (core#if (vector? .expr.2435) (list (.the",
".2269 (core#quote list->vector)) (.qq.2428 .depth.2434 (vector->list .expr.2435)",
")) (core#if (identifier? .expr.2435) (.rename.2424 .expr.2435) (list (.the.2269 ",
"(core#quote quote)) .expr.2435))))))))) ((core#lambda (.body.2436) (cons (.the.2",
"269 (core#quote let)) (cons (map cdr .renames.2423) (cons .body.2436 (core#quote",
" ()))))) (.qq.2428 1 (cadr .form.2421))))))))) #undefined)) (core#quote ())))) (",
"core#begin (.define-transformer.2268 (core#quote define-syntax) (core#lambda (.f",
"orm.2437 .env.2438) ((core#lambda (.formal.2439 .body.2440) (core#if (pair? .for",
"mal.2439) (cons (.the.2269 (core#quote define-syntax)) (cons (car .formal.2439) ",
"(cons (cons .the-lambda.2278 (cons (cdr .formal.2439) (append .body.2440 (core#q",
"uote ())))) (core#quote ())))) (cons .the-define-macro.2283 (cons .formal.2439 (",
"cons (cons (.the.2269 (core#quote transformer)) (cons (cons .the-begin.2279 (app",
"end .body.2440 (core#quote ()))) (core#quote ()))) (core#quote ())))))) (car (cd",
"r .form.2437)) (cdr (cdr .form.2437))))) (core#begin (.define-transformer.2268 (",
"core#quote letrec-syntax) (core#lambda (.form.2441 .env.2442) ((core#lambda (.fo",
"rmal.2443 .body.2444) (cons (core#quote let) (cons (core#quote ()) (append (map ",
"(core#lambda (.x.2445) (cons (.the.2269 (core#quote define-syntax)) (cons (car .",
"x.2445) (cons (cadr .x.2445) (core#quote ()))))) .formal.2443) (append .body.244",
"4 (core#quote ())))))) (car (cdr .form.2441)) (cdr (cdr .form.2441))))) (.define",
"-transformer.2268 (core#quote let-syntax) (core#lambda (.form.2446 .env.2447) (c",
"ons (.the.2269 (core#quote letrec-syntax)) (append (cdr .form.2446) (core#quote ",
"()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",

};

#if PIC_USE_LIBRARY
static const char boot_library_rom[][80] = {
"(core#begin (core#define mangle (core#lambda (.name.2448) (core#begin (core#if (",
"null? .name.2448) (error \"library name should be a list of at least one symbols\"",
" .name.2448) #undefined) (core#begin (core#define .->string.2449 (core#lambda (.",
"n.2451) (core#if (symbol? .n.2451) ((core#lambda (.str.2452) (core#begin (string",
"-for-each (core#lambda (.c.2453) (core#if ((core#lambda (.it.2454) (core#if .it.",
"2454 .it.2454 ((core#lambda (.it.2455) (core#if .it.2455 .it.2455 #f)) (char=? .",
"c.2453 #\\:)))) (char=? .c.2453 #\\.)) (error \"elements of library name may not co",
"ntain '.' or ':'\" .n.2451) #undefined)) .str.2452) .str.2452)) (symbol->string .",
"n.2451)) (core#if (core#if (number? .n.2451) (core#if (exact? .n.2451) (<= 0 .n.",
"2451) #f) #f) (number->string .n.2451) (error \"symbol or non-negative integer is",
" required\" .n.2451))))) (core#begin (core#define .join.2450 (core#lambda (.strs.",
"2456 .delim.2457) ((core#lambda () (core#begin (core#define .loop.2458 (core#lam",
"bda (.res.2459 .strs.2460) (core#if (null? .strs.2460) .res.2459 (.loop.2458 (st",
"ring-append .res.2459 .delim.2457 (car .strs.2460)) (cdr .strs.2460))))) (.loop.",
"2458 (car .strs.2456) (cdr .strs.2456))))))) (core#if (symbol? .name.2448) .name",
".2448 (string->symbol (.join.2450 (map .->string.2449 .name.2448) \".\")))))))) (c",
"ore#begin (core#define current-library (make-parameter (core#quote (picrin base)",
") mangle)) (core#begin (core#define *libraries* (make-dictionary)) (core#begin (",
"core#define find-library (core#lambda (.name.2461) (dictionary-has? *libraries* ",
"(mangle .name.2461)))) (core#begin (core#define make-library (core#lambda (.name",
".2462) ((core#lambda (.name.2463) ((core#lambda (.env.2464 .exports.2465) (core#",
"begin (set-identifier! (core#quote define-library) (core#quote define-library) .",
"env.2464) (core#begin (set-identifier! (core#quote import) (core#quote import) .",
"env.2464) (core#begin (set-identifier! (core#quote export) (core#quote export) .",
"env.2464) (core#begin (set-identifier! (core#quote cond-expand) (core#quote cond",
"-expand) .env.2464) (dictionary-set! *libraries* .name.2463 (cons .env.2464 .exp",
"orts.2465))))))) (make-environment (string->symbol (string-append (symbol->strin",
"g .name.2463) \":\"))) (make-dictionary))) (mangle .name.2462)))) (core#begin (cor",
"e#define library-environment (core#lambda (.name.2466) (car (dictionary-ref *lib",
"raries* (mangle .name.2466))))) (core#begin (core#define library-exports (core#l",
"ambda (.name.2467) (cdr (dictionary-ref *libraries* (mangle .name.2467))))) (cor",
"e#begin (core#define library-import (core#lambda (.name.2468 .sym.2469 .alias.24",
"70) ((core#lambda (.uid.2471) ((core#lambda (.env.2472) (set-identifier! .alias.",
"2470 .uid.2471 .env.2472)) (library-environment (current-library)))) (dictionary",
"-ref (library-exports .name.2468) .sym.2469)))) (core#begin (core#define library",
"-export (core#lambda (.sym.2473 .alias.2474) ((core#lambda (.env.2475 .exports.2",
"476) (dictionary-set! .exports.2476 .alias.2474 (find-identifier .sym.2473 .env.",
"2475))) (library-environment (current-library)) (library-exports (current-librar",
"y))))) (core#begin ((core#lambda (.define-transformer.2477) (core#begin (.define",
"-transformer.2477 (core#quote define-library) (core#lambda (.form.2478 ._.2479) ",
"((core#lambda (.name.2480 .body.2481) (core#begin ((core#lambda (.it.2482) (core",
"#if .it.2482 .it.2482 ((core#lambda (.it.2483) (core#if .it.2483 .it.2483 #f)) (",
"make-library .name.2480)))) (find-library .name.2480)) (with-dynamic-environment",
" (list (cons current-library .name.2480)) (core#lambda () (for-each (core#lambda",
" (.expr.2484) (eval .expr.2484 .name.2480)) .body.2481))))) (cadr .form.2478) (c",
"ddr .form.2478)))) (core#begin (.define-transformer.2477 (core#quote cond-expand",
") (core#lambda (.form.2485 ._.2486) ((core#lambda (.test.2487) (core#begin (core",
"#set! .test.2487 (core#lambda (.form.2488) ((core#lambda (.it.2489) (core#if .it",
".2489 .it.2489 ((core#lambda (.it.2490) (core#if .it.2490 .it.2490 ((core#lambda",
" (.it.2491) (core#if .it.2491 .it.2491 #f)) (core#if (pair? .form.2488) ((core#l",
"ambda (.key.2492) (core#if ((core#lambda (.it.2493) (core#if .it.2493 .it.2493 #",
"f)) (eqv? .key.2492 (core#quote library))) (find-library (cadr .form.2488)) (cor",
"e#if ((core#lambda (.it.2494) (core#if .it.2494 .it.2494 #f)) (eqv? .key.2492 (c",
"ore#quote not))) (not (.test.2487 (cadr .form.2488))) (core#if ((core#lambda (.i",
"t.2495) (core#if .it.2495 .it.2495 #f)) (eqv? .key.2492 (core#quote and))) ((cor",
"e#lambda () (core#begin (core#define .loop.2496 (core#lambda (.form.2497) ((core",
"#lambda (.it.2498) (core#if .it.2498 .it.2498 ((core#lambda (.it.2499) (core#if ",
".it.2499 .it.2499 #f)) (core#if (.test.2487 (car .form.2497)) (.loop.2496 (cdr .",
"form.2497)) #f)))) (null? .form.2497)))) (.loop.2496 (cdr .form.2488))))) (core#",
"if ((core#lambda (.it.2500) (core#if .it.2500 .it.2500 #f)) (eqv? .key.2492 (cor",
"e#quote or))) ((core#lambda () (core#begin (core#define .loop.2501 (core#lambda ",
"(.form.2502) (core#if (pair? .form.2502) ((core#lambda (.it.2503) (core#if .it.2",
"503 .it.2503 ((core#lambda (.it.2504) (core#if .it.2504 .it.2504 #f)) (.loop.250",
"1 (cdr .form.2502))))) (.test.2487 (car .form.2502))) #f))) (.loop.2501 (cdr .fo",
"rm.2488))))) (core#if #t #f #undefined)))))) (car .form.2488)) #f)))) (core#if (",
"symbol? .form.2488) (memq .form.2488 (features)) #f)))) (eq? .form.2488 (core#qu",
"ote else))))) ((core#lambda () (core#begin (core#define .loop.2505 (core#lambda ",
"(.clauses.2506) (core#if (null? .clauses.2506) #undefined (core#if (.test.2487 (",
"caar .clauses.2506)) (cons (make-identifier (core#quote begin) default-environme",
"nt) (append (cdar .clauses.2506) (core#quote ()))) (.loop.2505 (cdr .clauses.250",
"6)))))) (.loop.2505 (cdr .form.2485))))))) #undefined))) (core#begin (.define-tr",
"ansformer.2477 (core#quote import) (core#lambda (.form.2507 ._.2508) ((core#lamb",
"da (.caddr.2509 .prefix.2510 .getlib.2511) ((core#lambda (.extract.2512 .collect",
".2513) (core#begin (core#set! .extract.2512 (core#lambda (.spec.2514) ((core#lam",
"bda (.key.2515) (core#if ((core#lambda (.it.2516) (core#if .it.2516 .it.2516 ((c",
"ore#lambda (.it.2517) (core#if .it.2517 .it.2517 ((core#lambda (.it.2518) (core#",
"if .it.2518 .it.2518 ((core#lambda (.it.2519) (core#if .it.2519 .it.2519 #f)) (e",
"qv? .key.2515 (core#quote except))))) (eqv? .key.2515 (core#quote prefix))))) (e",
"qv? .key.2515 (core#quote rename))))) (eqv? .key.2515 (core#quote only))) (.extr",
"act.2512 (cadr .spec.2514)) (core#if #t (.getlib.2511 .spec.2514) #undefined))) ",
"(car .spec.2514)))) (core#begin (core#set! .collect.2513 (core#lambda (.spec.252",
"0) ((core#lambda (.key.2521) (core#if ((core#lambda (.it.2522) (core#if .it.2522",
" .it.2522 #f)) (eqv? .key.2521 (core#quote only))) ((core#lambda (.alist.2523) (",
"map (core#lambda (.var.2524) (assq .var.2524 .alist.2523)) (cddr .spec.2520))) (",
".collect.2513 (cadr .spec.2520))) (core#if ((core#lambda (.it.2525) (core#if .it",
".2525 .it.2525 #f)) (eqv? .key.2521 (core#quote rename))) ((core#lambda (.alist.",
"2526 .renames.2527) (map (core#lambda (.s.2528) ((core#lambda (.it.2529) (core#i",
"f .it.2529 .it.2529 ((core#lambda (.it.2530) (core#if .it.2530 .it.2530 #f)) .s.",
"2528))) (assq (car .s.2528) .renames.2527))) .alist.2526)) (.collect.2513 (cadr ",
".spec.2520)) (map (core#lambda (.x.2531) (cons (car .x.2531) (cadr .x.2531))) (c",
"ddr .spec.2520))) (core#if ((core#lambda (.it.2532) (core#if .it.2532 .it.2532 #",
"f)) (eqv? .key.2521 (core#quote prefix))) ((core#lambda (.alist.2533) (map (core",
"#lambda (.s.2534) (cons (.prefix.2510 (.caddr.2509 .spec.2520) (car .s.2534)) (c",
"dr .s.2534))) .alist.2533)) (.collect.2513 (cadr .spec.2520))) (core#if ((core#l",
"ambda (.it.2535) (core#if .it.2535 .it.2535 #f)) (eqv? .key.2521 (core#quote exc",
"ept))) ((core#lambda (.alist.2536) ((core#lambda () (core#begin (core#define .lo",
"op.2537 (core#lambda (.alist.2538) (core#if (null? .alist.2538) (core#quote ()) ",
"(core#if (memq (caar .alist.2538) (cddr .spec.2520)) (.loop.2537 (cdr .alist.253",
"8)) (cons (car .alist.2538) (.loop.2537 (cdr .alist.2538))))))) (.loop.2537 .ali",
"st.2536))))) (.collect.2513 (cadr .spec.2520))) (core#if #t (dictionary-map (cor",
"e#lambda (.x.2539) (cons .x.2539 .x.2539)) (library-exports (.getlib.2511 .spec.",
"2520))) #undefined)))))) (car .spec.2520)))) ((core#lambda (.import.2540) (core#",
"begin (core#set! .import.2540 (core#lambda (.spec.2541) ((core#lambda (.lib.2542",
" .alist.2543) (for-each (core#lambda (.slot.2544) (library-import .lib.2542 (cdr",
" .slot.2544) (car .slot.2544))) .alist.2543)) (.extract.2512 .spec.2541) (.colle",
"ct.2513 .spec.2541)))) (for-each .import.2540 (cdr .form.2507)))) #undefined))))",
" #undefined #undefined)) (core#lambda (.x.2545) (car (cdr (cdr .x.2545)))) (core",
"#lambda (.prefix.2546 .symbol.2547) (string->symbol (string-append (symbol->stri",
"ng .prefix.2546) (symbol->string .symbol.2547)))) (core#lambda (.name.2548) (cor",
"e#if (find-library .name.2548) .name.2548 (error \"library not found\" .name.2548)",
"))))) (.define-transformer.2477 (core#quote export) (core#lambda (.form.2549 ._.",
"2550) ((core#lambda (.collect.2551 .export.2552) (core#begin (core#set! .collect",
".2551 (core#lambda (.spec.2553) (core#if (symbol? .spec.2553) (cons .spec.2553 .",
"spec.2553) (core#if (core#if (list? .spec.2553) (core#if (= (length .spec.2553) ",
"3) (eq? (car .spec.2553) (core#quote rename)) #f) #f) (cons (list-ref .spec.2553",
" 1) (list-ref .spec.2553 2)) (error \"malformed export\"))))) (core#begin (core#se",
"t! .export.2552 (core#lambda (.spec.2554) ((core#lambda (.slot.2555) (library-ex",
"port (car .slot.2555) (cdr .slot.2555))) (.collect.2551 .spec.2554)))) (for-each",
" .export.2552 (cdr .form.2549))))) #undefined #undefined))))))) (core#lambda (.n",
"ame.2556 .macro.2557) (add-macro! .name.2556 .macro.2557))) ((core#lambda () (co",
"re#begin (make-library (core#quote (picrin base))) (core#begin (set-car! (dictio",
"nary-ref *libraries* (mangle (core#quote (picrin base)))) default-environment) (",
"core#begin ((core#lambda (.export-keywords.2558) (core#begin (.export-keywords.2",
"558 (core#quote (define lambda quote set! if begin define-macro let let* letrec ",
"letrec* let-values let*-values define-values quasiquote unquote unquote-splicing",
" and or cond case else => do when unless parameterize define-syntax syntax-quote",
" syntax-unquote syntax-quasiquote syntax-unquote-splicing let-syntax letrec-synt",
"ax syntax-error))) (core#begin (.export-keywords.2558 (core#quote (features eq? ",
"eqv? equal? not boolean? boolean=? pair? cons car cdr null? set-car! set-cdr! ca",
"ar cadr cdar cddr list? make-list list length append reverse list-tail list-ref ",
"list-set! list-copy map for-each memq memv member assq assv assoc current-input-",
"port current-output-port current-error-port port? input-port? output-port? port-",
"open? close-port eof-object? eof-object read-u8 peek-u8 read-bytevector! write-u",
"8 write-bytevector flush-output-port open-input-bytevector open-output-bytevecto",
"r get-output-bytevector number? exact? inexact? inexact exact = < > <= >= + - * ",
"/ number->string string->number procedure? apply symbol? symbol=? symbol->string",
" string->symbol make-identifier identifier? identifier=? identifier-base identif",
"ier-environment vector? vector make-vector vector-length vector-ref vector-set! ",
"vector-copy! vector-copy vector-append vector-fill! vector-map vector-for-each l",
"ist->vector vector->list string->vector vector->string bytevector? bytevector ma",
"ke-bytevector bytevector-length bytevector-u8-ref bytevector-u8-set! bytevector-",
"copy! bytevector-copy bytevector-append bytevector->list list->bytevector call-w",
"ith-current-continuation call/cc values call-with-values char? char->integer int",
"eger->char char=? char<? char>? char<=? char>=? current-exception-handlers with-",
"exception-handler raise raise-continuable error error-object? error-object-messa",
"ge error-object-irritants error-object-type string? string make-string string-le",
"ngth string-ref string-set! string-copy string-copy! string-fill! string-append ",
"string-map string-for-each list->string string->list string=? string<? string>? ",
"string<=? string>=? make-parameter with-dynamic-environment read make-dictionary",
" dictionary? dictionary dictionary-has? dictionary-ref dictionary-set! dictionar",
"y-delete! dictionary-size dictionary-map dictionary-for-each dictionary->alist a",
"list->dictionary dictionary->plist plist->dictionary make-record record? record-",
"type record-datum default-environment make-environment find-identifier set-ident",
"ifier! eval compile add-macro! make-ephemeron-table write write-simple write-sha",
"red display))) (.export-keywords.2558 (core#quote (find-library make-library cur",
"rent-library)))))) (core#lambda (.keywords.2559) ((core#lambda (.env.2560 .expor",
"ts.2561) (for-each (core#lambda (.keyword.2562) (dictionary-set! .exports.2561 .",
"keyword.2562 .keyword.2562)) .keywords.2559)) (library-environment (core#quote (",
"picrin base))) (library-exports (core#quote (picrin base)))))) (core#begin (core",
"#set! eval ((core#lambda (.e.2563) (core#lambda (.expr.2564 . .lib.2565) ((core#",
"lambda (.lib.2566) (.e.2563 .expr.2564 (library-environment .lib.2566))) (core#i",
"f (null? .lib.2565) (current-library) (car .lib.2565))))) eval)) (core#begin (ma",
"ke-library (core#quote (picrin user))) (current-library (core#quote (picrin user",
"))))))))))))))))))))",

};
#endif

void
pic_boot(pic_state *pic)
{
  pic_call(pic, pic_compile(pic, pic_read_cstr(pic, &boot_rom[0][0])), 0);
#if PIC_USE_LIBRARY
  pic_call(pic, pic_compile(pic, pic_read_cstr(pic, &boot_library_rom[0][0])), 0);
#endif
}
